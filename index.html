<script>
        // DOM элементы (все как было)
        const imageUpload = document.getElementById('image-upload');
        const hintSection = document.getElementById('hint-section');
        const uploadSection = document.getElementById('upload-section');
        const previewSection = document.getElementById('preview-section');
        const previewImage = document.getElementById('preview-image');
        const loaderSection = document.getElementById('loader-section');
        const resultsSection = document.getElementById('results-section');
        const errorSection = document.getElementById('error-section');
        const errorText = document.getElementById('error-text');
        const btnNewPhoto = document.getElementById('btn-new-photo');

        // Результаты (все как было)
        const resultClothes = document.getElementById('result-clothes');
        const resultStyle = document.getElementById('result-style');
        const stars = document.getElementById('stars');
        const ratingText = document.getElementById('rating-text');
        const resultSuggestions = document.getElementById('result-suggestions');

        // --- ИЗМЕНЕНИЯ НАЧИНАЮТСЯ ЗДЕСЬ ---

        // API
        // const API_URL = "..." // УДАЛЕНО - теперь это на бэкенде
        // const API_KEY = "..." // УДАЛЕНО - теперь это на бэкенде
        // const SYSTEM_PROMPT = "..." // УДАЛЕНО - теперь это на бэкенде

        // Новый URL - это адрес НАШЕЙ бэкенд-функции на Vercel
        const BACKEND_API_URL = '/api/gemini'; 

        // --- (Код ниже до `analyzeImage` остается без изменений) ---

        // Загрузка файла
        imageUpload.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            if (!file.type.startsWith('image/')) {
                showError('Пожалуйста, выбери изображение');
                return;
            }

            resetUI();
            showPreview(file);
            await processImage(file);
        });

        // Новое фото
        btnNewPhoto.addEventListener('click', () => {
            resetToInitial();
        });

        // Превью
        function showPreview(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                previewImage.src = e.target.result;
                previewImage.style.display = 'block';
                uploadSection.classList.add('hidden');
                hintSection.classList.add('hidden');
                previewSection.classList.remove('hidden');
            };
            reader.readAsDataURL(file);
        }

        // Обработка
        async function processImage(file) {
            loaderSection.style.display = 'block';
            loaderSection.classList.remove('hidden');

            try {
                const base64Data = await resizeAndConvert(file);
                // --- ИЗМЕНЕНО ---
                // Вызываем нашу функцию `analyzeImage`, которая теперь обращается к бэкенду
                await analyzeImage(base64Data);
            } catch (error) {
                console.error(error);
                showError(`Не удалось проанализировать фото: ${error.message}`);
            } finally {
                loaderSection.style.display = 'none';
                loaderSection.classList.add('hidden');
            }
        }

        // Сжатие (без изменений)
        function resizeAndConvert(file, maxSize = 512, quality = 0.7) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => {
                        let width = img.width;
                        let height = img.height;

                        if (width > height) {
                            if (width > maxSize) {
                                height *= maxSize / width;
                                width = maxSize;
                            }
                        } else {
                            if (height > maxSize) {
                                width *= maxSize / height;
                                height = maxSize;
                            }
                        }

                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);

                        resolve(canvas.toDataURL('image/jpeg', quality).split(',')[1]);
                    };
                    img.onerror = reject;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // --- Функция `analyzeImage` СИЛЬНО ИЗМЕНЕНА ---
        async function analyzeImage(base64Data) {
            // 1. Готовим payload для НАШЕГО бэкенда
            const payload = {
                imageData: base64Data
            };

            try {
                // 2. Вызываем наш бэкенд (функция `callBackendApi` ниже)
                const text = await callBackendApi(BACKEND_API_URL, payload);
                // 3. Отображаем результат (эта функция не изменилась)
                displayResults(text);
            } catch (error) {
                console.error('Ошибка вызова бэкенда:', error);
                showError(error.message); // Показываем ошибку, которую вернул наш бэкенд
            }
        }

        // Отображение (без изменений)
        function displayResults(text) {
            // ... (весь твой код парсинга и отображения остается здесь) ...
            const cleanedText = text.replace(/\*\*/g, '');
            let outfit = "Не удалось распознать.";
            let style = "Не удалось распознать.";
            let rating = 7; 
            let advice = "Не удалось распознать.";

            const outfitMatch = cleanedText.match(/(?:Вы одеты в:|Одежда:)([\s\S]*?)(?:Ваш стиль:|Стиль:|Сочетание одежды:|Оценка:|Что можно добавить:|Советы:|$)/i);
            if (outfitMatch && outfitMatch[1]) {
                outfit = outfitMatch[1].trim().replace(/^- /gm, '').replace(/\n/g, '<br>');
            }
            const styleMatch = cleanedText.match(/(?:Ваш стиль:|Стиль:)([\s\S]*?)(?:Сочетание одежды:|Оценка:|Что можно добавить:|Советы:|$)/i);
            if (styleMatch && styleMatch[1]) {
                style = styleMatch[1].trim().replace(/^- /gm, '').replace(/\n/g, '<br>');
            }
            const ratingMatch = cleanedText.match(/(?:Сочетание одежды:|Оценка:)([\s\S]*?)(?:Что можно добавить:|Советы:|$)/i);
            if (ratingMatch && ratingMatch[1]) {
                const ratingNumMatch = ratingMatch[1].match(/(\d+)/);
                if (ratingNumMatch) {
                    rating = parseInt(ratingNumMatch[1], 10);
                }
            }
            const adviceMatch = cleanedText.match(/(?:Что можно добавить:|Советы:|Рекомендации:)([\s\S]*?)$/i);
            if (adviceMatch && adviceMatch[1]) {
                advice = adviceMatch[1].trim().replace(/^- /gm, '• ').replace(/\n/g, '<br>');
            }
            
            resultClothes.innerHTML = outfit;
            resultStyle.innerHTML = style;
            displayStars(rating);
            ratingText.textContent = `${rating}/10`;
            resultSuggestions.innerHTML = advice;

            resultsSection.style.display = 'block';
            resultsSection.classList.remove('hidden');
        }

        // Звёзды (без изменений)
        function displayStars(rating) {
            stars.innerHTML = '';
            for (let i = 0; i < 10; i++) {
                const star = document.createElement('div');
                star.className = i < rating ? 'star' : 'star empty';
                stars.appendChild(star);
            }
        }

        // Ошибка (без изменений)
        function showError(message) {
            errorText.textContent = message;
            errorSection.style.display = 'block';
            errorSection.classList.remove('hidden');
        }

        // Сброс UI (без изменений)
        function resetUI() {
            errorSection.classList.add('hidden');
            errorSection.style.display = 'none';
            resultsSection.classList.add('hidden');
            resultsSection.style.display = 'none';
            resultClothes.innerHTML = "";
            resultStyle.innerHTML = "";
            resultSuggestions.innerHTML = "";
            ratingText.textContent = "";
            stars.innerHTML = "";
        }

        // Полный сброс (без изменений)
        function resetToInitial() {
            resetUI();
            hintSection.classList.remove('hidden');
            uploadSection.classList.remove('hidden');
            previewSection.classList.add('hidden');
            loaderSection.classList.add('hidden');
            loaderSection.style.display = 'none';
            imageUpload.value = '';
        }

        // --- Функция `callGeminiWithRetry` ПЕРЕИМЕНОВАНА и ИЗМЕНЕНА ---
        // Теперь она обращается к НАШЕМУ бэкенду
        async function callBackendApi(url, payload, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    // 1. Делаем запрос к нашему /api/gemini
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                        // Ключ API_KEY здесь больше не нужен!
                    });

                    // 2. Получаем JSON от нашего бэкенда
                    const result = await response.json();

                    // 3. Проверяем, не вернул ли бэкенд ошибку
                    if (!response.ok) {
                        // `result.error` - это то, что мы отправили с бэкенда
                        throw new Error(result.error || `Ошибка сервера: ${response.status}`);
                    }

                    // 4. Если все ОК, наш бэкенд вернул { text: "..." }
                    if (result.text) {
                        return result.text;
                    } else {
                        throw new Error('Бэкенд вернул некорректный ответ.');
                    }
                } catch (error) {
                    console.warn(`Попытка ${i + 1} не удалась. Ошибка: ${error.message}`);
                    if (i === retries - 1) {
                         // Прокидываем ошибку наверх, чтобы `showError` ее показал
                        throw error;
                    }
                    await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
                }
            }
            throw new Error('Не удалось подключиться к API после нескольких попыток.');
        }
    </script>
</body>
</html>
